🤔 section1 에서의 기본 개발환경 설정후 
node dist/index.js로 파일을 실행하면 오류가 뜸
이때 package.json 에서   "type": "module" 을 넣어주어야
모듈로 인식하여 출력가능하다.


📁 Chapter1 [기본타입]
1. 원시타입 (Primitive Type)>> 하나의 값만 저장하는 타입
  number, string, boolean, null, undefined
  let num1: number = 1 에서
   ` : type명 `을 붙이는 것을 타입주석(Type Annotation)이라 부른다.
2. 리터럴 타입>> 값 그 자체가 타입이 되는 타입.

📁 Chapter2 [배열과 튜플]
1. 배열타입 정의 방법
  1) 배열에 들어가는 요소의 타입이 같은 경우 
    let 변수명: 타입[]  = [...]
    let 변수명: Array<타입> = [...]  >> 제네릭방법이라 부른다.
  
  2) 배열에 들어가는 요소의 타입이 다른 경우 (유니온타입)
    let 변수명: (타입1|타입2|..)[]  = [...];
  3) 다차원 배열의 타입을 정의하는 방법
    let 변수명: 타입[][] = [[...],[...]];

2. 튜플
  타입스크립트에서만 존재하는 용법으로 길이와 타입이 고정된 배열을 말함
  1) 선언법 
    let 변수: [타입1,타입2] = [값(타입1의값),값(타입2의값)]  =>> 길이가 2이고 타입1과 타입2가 순서대로 들어가는 배열
  2) 다중배열인 경우 
    let 변수: [타입1,타입2][] = [[타입1값,타입2값],[타입1값,타입2값],..]
  3) 주의사항
    실제로 튜플은 컴파일을 했을때 일반 js 배열과 같다. 따라서 push나 pop 메소드를 통해 값을 추가,삭제할수있다.
    하지만 지정된 갯수를 초과하거나 그 이하로 만들 수 있기 때문에 사용시 주의가 필요.


📁 Chapter3 [객체]
  1. 객체의 타입지정
    타입을 object로  지정하는 경우 점 표기법으로 해당 객체의 값을 꺼내올때 오류가 발생
    object를 그냥 객체고 그안은 몰라 이런식으로 인식하기 때문이다.
    >>> 따라서 객체리터럴 타입 으로 표기한다.

  2. 객체리터럴타입 표기법 
    1)선언
      let 변수명 : { 객체의키: 키타입, 객체의 키:키타입} = { 키: 값 , 키:값 } 
      🐸 객체를 구조기준으로 정의 => 구조적 타입 시스템 => property based Type System (↔ 명목적타입시스템)
    2) 옵셔널 프로퍼티 (` ? `)
      let user: { 
        id?:number; // ? 를 붙이면 있어도 되고 없어도 되는데 있는경우 타입이 다음과 같다는것을 알려주는 속성
                    // 선택적 프로퍼티 (Optional property) 라고 부른다.
        name:string;
      } ={     
        name:"HINZOO",
      };
    3) readonly >> 읽기 전용 프로퍼티로 만들어줌
      let config: {
          readonly apikey: string;
        } = {
          apikey: "딱봐도 중요해보이지, 변경되면 안됨.",
        };

📁 Chapter4 [타입별칭과 인덱스 시그니처]
  1. 타입별칭 : 객체의 키가 많은 경우 매번 일일히 타이핑하기 힘들 때, 
                초기에 한번만 해당객체의 타입을 지정해두고 반복사용
     - 주의 : 동일한 스코프에서 중복된 타입별칭을 사용할 수 없음.
              일반 변수들 처럼 스코프안에서 동일명칭을 쓰는것은 가능 (ex.함수 안)
  2. 인덱스 시그니처 : key와 value의 타입을 규칙을 기준으로 객체의 타입을 정의할수있는 문법
     - 주의 : 인덱스 시그니처 타입은 이규칙을 위반하지만 않으면 모든 규칙을 허용함.
       ex)
          type CountryNumberCodes = {
            [key:string]: number;
             }

          let countryNumberCodes : CountryNumberCodes = {  };//빈값이어도 오류가 안남.
          해결을 위하여 객체의 값중 하나는 키와 타입을 적어둔다.
           type CountryNumberCodes = {
            [key:string]: number;
            Korea : 450 
           }
     - 주의2 :인덱스 시그니쳐를 사용하면서 동시에 추가적인 프로퍼티를 또 정의할 때에는 
     인덱스 시그니쳐의 value 타입과 직접 추가한 프로퍼티의 value 타입이 호환되거나 일치해야 한다. 
      -> 호환에 관해서는 section3 에서 다룸
      ex)
      type CountryNumberCodes = {
        [key:string]: number;
         Korea: string; //🚫오류 타입이 일치하지 않을 경우 적용할수없다.
      }


📁 Chapter5 [Enum 타입]
  1. 개념
    ts에만 존재하는 타입으로, 여러가지 값들에 각각 이름을 부여해 열거해두고 사용하는 타입
    1) 숫자형 Enum
       enum Role { 
        ADMIN = 0,
        USER = 1,
        GUEST = 2,
      } 
      //숫자를 제거하더라도 자동으로 0번부터 순차대로 번호가 할당된다.
      //10번부터 시작하고 싶다면 제일 ADMIN=10만 써줘도 순차대로 1씩증가.
      //중간인 USER에  10을 할당하면 ADMIN =0, USER =10 , GUEST = 11
    2) 문자형 Enum
  2. 주의
    enum은 다른 ts전용 타입들과 별개로 컴파일 결과 사라지지 않는다. 
    자바스크립트의 객체로 변환된다.
  

📁 Chapter6 [Any 와 Unknown 타입]
  1. Any 타입
    특정 변수의 타입을 확실히 모를 때 사용
    변수에 모든 타입의 값이 들어갈 수 있으며,
    특정 타입으로 정의된 변수에도 값을 넣을 수 있다.
    또한 다른 타입의 함수적용도 가능하다.
    🚫타입 검사를 안하는 것과 마찬가지이기 때문에 최대한 사용을 자제한다.
  2. Unknown 타입
    특정 변수의 타입을 확실히 모를 때 사용
    변수에 모든 타입의 값이 들어갈 수 있으며,
    특정 타입으로 정의된 변수에는 값을 넣을 수 없다. (ANY와의 차이점)
    또한 연산이 불가하며 다른타입의 함수적용도 불가능 하다.
    타입정제과정을 거치면 대입이 가능해지기 때문에 ANY보다는 Unknown을 주로 사용한다.
      >>타입정제 과정
      if(typeof unknownVar === "number"){
          num = unknownVar ; 
        }


📁 Chapter7 [Void와 Never 타입]
  1. void : 아무것도 없음을 의미하는 타입
    변수로 보면 undefined 만 담을 수 있다.
    null의 경우  "strictNullChecks": true 로 하면 담을 수 있음.
    🤔 void랑 undefined가 같은데 왜 void 타입을 만들었을까?
      함수 작성시 undefined나 null은 return문을 꼭 작성해줘야하기 때문이다. 
      void는 return문 작성이 필요없음.
  2. never : 존재하지않는 불가능한 타입
   1) 예시1| 무한루프를 돌아 반환값이 있는것 자체가 모순인 경우 
        function func5(): never {
          while(true){} 
        }
      예시2| 에러가 생겨서 실행이 종료되는 경우 마찬가지로 반환값이 절대 생길수 없는 경우
        function func6(): never {
          throw new Error(); 
        }
   2) 변수의 경우 아무타입도 받을 수 없다.
      any 타입도 받을 수 없다.
